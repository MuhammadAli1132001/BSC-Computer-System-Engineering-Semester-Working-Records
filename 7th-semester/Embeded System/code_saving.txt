

#include <MSP430F2418.h>
 
#define a BIT0
#define b BIT1
#define c BIT2
#define d BIT4
#define e BIT5
#define f BIT6
#define g BIT7
 
 
void main(void)
{
    WDTCTL = WDTPW + WDTHOLD;
    P6DIR = 0xFF;
    P7DIR = 0xFF;
    P8DIR = 0xFF;
    P1DIR = 0x00;
    P2DIR = 0x00;

P6DIR = BIT7 | BIT1 | BIT0;
P7DIR = BIT7 | BIT6;
P8DIR = BIT7;

 
    while(1)
    {
        if((P1IN & BIT3)==0)
        {
         P7OUT = BIT7 | BIT1;
	 P8OUT = 0x0C;

        }
    }
}

 

#include <MSP430F2418.h>
#include <stdint.h>
int main (void) { 
	uint16_t  x= 0x01;
	uint16_t  dir=0;


	WDTCTL = WDTPW  | WDTHOLD;
	P1DIR = 0xFF;
	P2DIR = 0x00;
	
	P1OUT = 0x01;
	

 while(1)
	{
	 if(!(P2IN  &  0x1)) {
	 dir=~dir; 
	 }
	if(dir==0){
     	__delay_cycles(1000000);
			 if (x== 0x80)
      {
			x=1;
      }  
		  else
    {		
	       x= x<<1;
     }
	P1OUT = x;
   }

	if(dir==1){
     	__delay_cycles(1000000);
			 if (x== 0x01)
      {
			x=0x80;
      }  
		  else
    {		
	       x= x<<1;
     }
	P1OUT = x;
   }
  }
 }









/* Main.c file generated by New Project wizard
*
* Created: Sat Nov 13 2022
* Processor: MSP430F2418
* Compiler: GCC for MSP430
*/
#include <MSP430.h>
#include <stdint.h>
int main (void)
{ 
 int16_t x = 0x0001;
 uint16_t y = 0x0;
 //stop watchdog timer
 WDTCTL =WDTPW | WDTHOLD;
 
 P1DIR =0xFF ; //FOR LEDs output
 P1OUT =0x00; // initialized all leds off
 P2DIR |= ~BIT0; // for intput button use only p2.0
 P2IES = BIT0; //hi to low edge
 P2IFG = 0; //clear all p2 interrupt flags
 P2IE =BIT0;// interrupt enable
 
 
 // loop forever
 for(;;)
 { 
 __bis_SR_register(GIE); // global interuupt flags enable
 x=1;
 while(x != 0x100) // with interrupt not occure run this
 {
P1OUT = x;
x =x << 1;
while(y != 0x2FFF)
{
 y =y+1;
}
y=0;
 } 
 
 }
}
#pragma vector = PORT2_VECTOR
__interrupt void Port_2(void)
{
 int16_t x = 0x80;
 uint16_t y = 0x0;
 
 
 while(1)
 {
  
 x=0x80;
 while(x != 0)
 {
P1OUT = x;
x =x >> 1;
while(y != 0x2FFF)
{
 y =y+1;
}
y=0;
  } 
 }
 P2IFG &= ~ BIT0; //clear interrupt flag 
}
















/* Main.c file generated by New Project wizard
 *
 * Created:   Sun Dec 11 2022
 * Processor: MSP430F2418
 * Compiler:  GCC for MSP430
 */

#include <MSP430F2418.h>
#include <stdint.h>
#define LED1 BIT0
#define LED2 BIT1
uint16_t x= 0;	
int main (void)
 { 
 	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	BCSCTL1 = CALBC1_1MHZ;
	DCOCTL = CALDCO_1MHZ;
	P2OUT = ~LED1 | ~LED2;  //preload both  leds on
	P2DIR = LED1 | LED2;
	TACCR0 = 50000;
	TACCTL0 = CCIE;
	TACTL = MC_1 | ID_0 | TASSEL_2 | TACLR;
	
  for(;;){
   __bis_SR_register(LPM4_bits | GIE);
   }
  }
  
 #pragma vector= TIMERA0_VECTOR
 __interrupt void TA0_ISR(void)
 {
   x++;
   if(x==10){
   x=0;
   P2OUT ^= LED1 | LED2;

   }
         
 }   





/* Main.c file generated by New Project wizard
 *
 * Created:   Sun Dec 11 2022
 * Processor: MSP430F2418
 * Compiler:  GCC for MSP430
 */

#include <MSP430F2418.h>
#include <stdint.h>
#define LED1 BIT2
#define LED2 BIT3
uint16_t x= 0;	
int main (void)
 { 
 	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	BCSCTL1 = CALBC1_1MHZ;
	DCOCTL = CALDCO_1MHZ;
	P1OUT = LED1;
	P1DIR = LED1 | LED2;
	TACCR0 = 125;                  //125 micro_sec
	TACCTL0 = CCIE;
	TACTL = MC_1 | ID_0 | TASSEL_2 | TACLR;
	
  for(;;){
   __bis_SR_register(LPM4_bits | GIE);
   }
  }
  
  tpragma vector TIMERO AI VECTOR

interrupt void TIMERAI ISR (void) // ISR for TACCRn CCIEG and TAIFG

taiv temp TAOIV,

necessary because accessing TAIV resets it

switch (taiv temp) 
V/ Efficient switch-implementation

case TAIV TACCRI

P4OUT A green led

TAOCCRI += msec50 break;

//Toggle Green Led/ Run freely in Continous Mode

case TAIV TACCR2:

P4OUT  red led

TAOCCR2 += msec 25 break;

return;

//Toggle Red LED
  
 #pragma vector= TIMERA0_VECTOR
 __interrupt void TA0_ISR(void)
 { 
 
   if(~LED1)
   {
      P1OUT ^= LED1;
   }
   
   if(LED1)
   {
    x++;
     if (x==3){
     x=0;
     P1OUT ^= LED1;
    }
  }
}   




#include <MSP430F2418.h>
#include <stdint.h>

#define msec_25  25000
#define msec_50  50000

#define LED1 BIT0
#define LED2 BIT1
uint16_t x= 0;	

int main (void)
 { 
 	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	BCSCTL1 = CALBC1_1MHZ;
	DCOCTL = CALDCO_1MHZ;
	
	TA0CCR1 = msec_25;                  //25 micro_sec
	TA0CCTL1 = CCIE;
	
	P4DIR = LED1 | LED2;
	P4OUT = 0;
	TA0CCR2 = msec_50;                  //50 micro_sec
	TA0CCTL2 = CCIE;
	
	TA0CTL = TASSEL_2|MC_2|ID_0|TACLR|TAIE;

  while(1){
   __bis_SR_register(GIE);
   }
   return 0;
  }
  
#pragma vector = TIMER0_A1_VECTOR
__interrupt void TIMERA1_ISR (void) // ISR for TACCRn CCIEG and TAIFG
{
   x = TA0IV;                          //necessary because accessing TAIV resets it
   switch (x) // Efficient switch-implementation
   {
   case TAIV_TACCR1:
   P4OUT ^= LED1;
   TA0CCR1 += msec_50;
   break;
                                 //Toggle Green Led/ Run freely in Continous Mode
   case TAIV_TACCR2:
   P4OUT ^= LED2;
   TA0CCR2 += msec_25;
   break;
   
 return;
   }
}